import { parseGitStatusScriptOutput } from "@/common/utils/git/gitStatus";

/**
 * Unit tests for parseGitStatusScriptOutput â€” the parser for the bash script
 * output generated by generateGitStatusScript(). Pure function, no I/O.
 */

// Helper to build script output matching the bash echo format
function buildOutput(opts: {
  headBranch?: string;
  primaryBranch?: string;
  ahead?: number;
  behind?: number;
  dirty?: number;
  outAdd?: number;
  outDel?: number;
  inAdd?: number;
  inDel?: number;
}): string {
  const {
    headBranch = "feature-x",
    primaryBranch = "main",
    ahead = 0,
    behind = 0,
    dirty = 0,
    outAdd = 0,
    outDel = 0,
    inAdd = 0,
    inDel = 0,
  } = opts;
  return [
    "---HEAD_BRANCH---",
    headBranch,
    "---PRIMARY---",
    primaryBranch,
    "---AHEAD_BEHIND---",
    `${ahead}\t${behind}`,
    "---DIRTY---",
    `${dirty}`,
    "---LINE_DELTA---",
    `${outAdd} ${outDel} ${inAdd} ${inDel}`,
  ].join("\n");
}

describe("parseGitStatusScriptOutput", () => {
  it("parses headBranch from output", () => {
    const result = parseGitStatusScriptOutput(buildOutput({ headBranch: "my-feature" }));
    expect(result).not.toBeNull();
    expect(result!.headBranch).toBe("my-feature");
  });

  it("returns empty headBranch for detached HEAD", () => {
    // git rev-parse --abbrev-ref HEAD returns "HEAD" for detached state,
    // but the script may output empty string on error
    const result = parseGitStatusScriptOutput(buildOutput({ headBranch: "" }));
    expect(result).not.toBeNull();
    expect(result!.headBranch).toBe("");
  });

  it("returns empty headBranch when HEAD_BRANCH section is missing (old script output)", () => {
    // Simulate output from an older version of the script that doesn't include HEAD_BRANCH
    const oldOutput = [
      "---PRIMARY---",
      "main",
      "---AHEAD_BEHIND---",
      "3\t1",
      "---DIRTY---",
      "2",
      "---LINE_DELTA---",
      "10 5 3 2",
    ].join("\n");
    const result = parseGitStatusScriptOutput(oldOutput);
    expect(result).not.toBeNull();
    expect(result!.headBranch).toBe("");
    // Other fields still parse correctly
    expect(result!.ahead).toBe(3);
    expect(result!.behind).toBe(1);
  });

  it("parses all fields from typical output", () => {
    const result = parseGitStatusScriptOutput(
      buildOutput({
        headBranch: "fix/branch-poll",
        primaryBranch: "main",
        ahead: 5,
        behind: 2,
        dirty: 3,
        outAdd: 100,
        outDel: 40,
        inAdd: 20,
        inDel: 10,
      })
    );
    expect(result).toEqual({
      headBranch: "fix/branch-poll",
      primaryBranch: "main",
      ahead: 5,
      behind: 2,
      dirtyCount: 3,
      outgoingAdditions: 100,
      outgoingDeletions: 40,
      incomingAdditions: 20,
      incomingDeletions: 10,
    });
  });

  it("parses clean workspace (zeros)", () => {
    const result = parseGitStatusScriptOutput(buildOutput({}));
    expect(result).not.toBeNull();
    expect(result!.ahead).toBe(0);
    expect(result!.behind).toBe(0);
    expect(result!.dirtyCount).toBe(0);
    expect(result!.outgoingAdditions).toBe(0);
    expect(result!.outgoingDeletions).toBe(0);
  });

  it("returns null for garbage input", () => {
    expect(parseGitStatusScriptOutput("not valid output")).toBeNull();
  });

  it("returns null for empty string", () => {
    expect(parseGitStatusScriptOutput("")).toBeNull();
  });

  it("handles branch names with slashes", () => {
    const result = parseGitStatusScriptOutput(
      buildOutput({ headBranch: "user/feature/deep-nested" })
    );
    expect(result).not.toBeNull();
    expect(result!.headBranch).toBe("user/feature/deep-nested");
  });
});
