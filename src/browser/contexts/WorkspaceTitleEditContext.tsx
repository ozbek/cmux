import React, { createContext, useContext, useState, useCallback, useRef } from "react";
import type { Result } from "@/common/types/result";

interface TitleEditResult {
  success: boolean;
  error?: string;
}

type RegenerateTitleResult = Result<{ title: string }, string>;

interface TitleEditContextValue {
  editingWorkspaceId: string | null;
  requestEdit: (workspaceId: string, currentTitle: string) => boolean;
  confirmEdit: (workspaceId: string, newTitle: string) => Promise<TitleEditResult>;
  cancelEdit: () => void;
  /** Workspace IDs whose titles are currently being generated by AI. */
  generatingTitleWorkspaceIds: ReadonlySet<string>;
  /** Wraps an async title-generation call with loading state management. */
  wrapGenerateTitle: (workspaceId: string, fn: () => Promise<RegenerateTitleResult>) => void;
}

const TitleEditContext = createContext<TitleEditContextValue | null>(null);

interface TitleEditProviderProps {
  children: React.ReactNode;
  onUpdateTitle: (
    workspaceId: string,
    newTitle: string
  ) => Promise<{ success: boolean; error?: string }>;
}

export const TitleEditProvider: React.FC<TitleEditProviderProps> = ({
  children,
  onUpdateTitle,
}) => {
  const [editingWorkspaceId, setEditingWorkspaceId] = useState<string | null>(null);
  const [originalTitle, setOriginalTitle] = useState<string>("");

  const requestEdit = useCallback(
    (workspaceId: string, currentTitle: string): boolean => {
      // Only allow one workspace to be edited at a time
      if (editingWorkspaceId !== null && editingWorkspaceId !== workspaceId) {
        return false;
      }

      setEditingWorkspaceId(workspaceId);
      setOriginalTitle(currentTitle);
      return true;
    },
    [editingWorkspaceId]
  );

  const confirmEdit = useCallback(
    async (workspaceId: string, newTitle: string): Promise<TitleEditResult> => {
      const trimmedTitle = newTitle.trim();

      // Short-circuit if title hasn't changed
      if (trimmedTitle === originalTitle) {
        setEditingWorkspaceId(null);
        setOriginalTitle("");
        return { success: true };
      }

      if (!trimmedTitle) {
        return { success: false, error: "Title cannot be empty" };
      }

      const result = await onUpdateTitle(workspaceId, trimmedTitle);

      if (result.success) {
        setEditingWorkspaceId(null);
        setOriginalTitle("");
      }

      return result;
    },
    [originalTitle, onUpdateTitle]
  );

  const cancelEdit = useCallback(() => {
    setEditingWorkspaceId(null);
    setOriginalTitle("");
  }, []);

  // --- Generate title loading state ---
  const [generatingTitleWorkspaceIds, setGeneratingTitleWorkspaceIds] = useState<Set<string>>(
    () => new Set()
  );
  const regeneratingWorkspaceIdsRef = useRef<Set<string>>(new Set());

  const wrapGenerateTitle = useCallback(
    (workspaceId: string, fn: () => Promise<RegenerateTitleResult>) => {
      // Ignore duplicate triggers while a regeneration is already in flight for this workspace.
      if (regeneratingWorkspaceIdsRef.current.has(workspaceId)) {
        return;
      }

      regeneratingWorkspaceIdsRef.current.add(workspaceId);
      setGeneratingTitleWorkspaceIds((current) => {
        if (current.has(workspaceId)) {
          return current;
        }
        const next = new Set(current);
        next.add(workspaceId);
        return next;
      });

      void Promise.resolve()
        .then(() => fn())
        .then((result) => {
          if (!result.success && typeof window !== "undefined") {
            window.alert(result.error);
          }
        })
        .catch((error: unknown) => {
          if (typeof window !== "undefined") {
            window.alert(error instanceof Error ? error.message : String(error));
          }
        })
        .finally(() => {
          regeneratingWorkspaceIdsRef.current.delete(workspaceId);
          setGeneratingTitleWorkspaceIds((current) => {
            if (!current.has(workspaceId)) {
              return current;
            }
            const next = new Set(current);
            next.delete(workspaceId);
            return next;
          });
        });
    },
    []
  );

  const value: TitleEditContextValue = {
    editingWorkspaceId,
    requestEdit,
    confirmEdit,
    cancelEdit,
    generatingTitleWorkspaceIds,
    wrapGenerateTitle,
  };

  return <TitleEditContext.Provider value={value}>{children}</TitleEditContext.Provider>;
};

export const useTitleEdit = (): TitleEditContextValue => {
  const context = useContext(TitleEditContext);
  if (!context) {
    throw new Error("useTitleEdit must be used within a TitleEditProvider");
  }
  return context;
};
