/**
 * Unified executor for background bash processes.
 *
 * ALL bash commands are spawned through this executor with background-style
 * infrastructure (nohup, file output, exit code trap). This enables:
 *
 * 1. Uniform code path - one spawn mechanism for all bash commands
 * 2. Crash resilience - output always persisted to files
 * 3. Seamless fgâ†’bg transition - "background this" = "stop waiting"
 *
 * Uses runtime.tempDir() for runtime-agnostic temp directory resolution.
 * Works identically for local and SSH runtimes.
 */

import type { Runtime, BackgroundHandle, ExecStream } from "@/node/runtime/Runtime";
import * as fs from "fs/promises";
import * as path from "path";
import { log } from "./log";
import {
  buildWrapperScript,
  buildSpawnCommand,
  parsePid,
  parseExitCode,
  buildTerminateCommand,
  shellQuote,
} from "@/node/runtime/backgroundCommands";
import { execBuffered, writeFileString } from "@/node/utils/runtime/helpers";
import { NON_INTERACTIVE_ENV_VARS } from "@/common/constants/env";
import { toPosixPath } from "@/node/utils/paths";

/**
 * Quote a path for shell commands.
 * On Windows, first converts to POSIX format, then shell-quotes.
 * On Unix, just shell-quotes (handles spaces, special chars).
 */
function quotePathForShell(p: string): string {
  const posixPath = toPosixPath(p);
  return shellQuote(posixPath);
}

/** Safe fallback cwd for exec calls - /tmp exists on all POSIX systems (including WSL/Git Bash) */
const FALLBACK_CWD = "/tmp";

/** Helper to extract error message for logging */
function errorMsg(error: unknown): string {
  return error instanceof Error ? error.message : String(error);
}

/** Subdirectory under temp for background process output */
export const BG_OUTPUT_SUBDIR = "mux-bashes";

/** Output filename for combined stdout/stderr */
export const OUTPUT_FILENAME = "output.log";

/** Exit code filename */
export const EXIT_CODE_FILENAME = "exit_code";

/**
 * Compute paths for a background process output directory.
 * @param bgOutputDir Base directory (e.g., /tmp/mux-bashes or ~/.mux/sessions)
 * @param workspaceId Workspace identifier
 * @param processId Process identifier
 */
export function computeOutputPaths(
  bgOutputDir: string,
  workspaceId: string,
  processId: string
): { outputDir: string; outputPath: string; exitCodePath: string } {
  const outputDir = `${bgOutputDir}/${workspaceId}/${processId}`;
  return {
    outputDir,
    outputPath: `${outputDir}/${OUTPUT_FILENAME}`,
    exitCodePath: `${outputDir}/${EXIT_CODE_FILENAME}`,
  };
}

/**
 * Options for spawning a process
 */
export interface SpawnOptions {
  /** Working directory for command execution */
  cwd: string;
  /** Workspace ID for output directory organization */
  workspaceId: string;
  /** Process ID (e.g., "bash_1") - generated by BackgroundProcessManager */
  processId: string;
  /** Environment variables to inject */
  env?: Record<string, string>;
}

/**
 * Result of spawning a process
 */
export type SpawnResult =
  | { success: true; handle: BackgroundHandle; pid: number; outputDir: string }
  | { success: false; error: string };

/**
 * Spawn a background process using runtime.exec (works for both local and SSH).
 *
 * All processes get the same infrastructure:
 * - nohup/setsid for process isolation
 * - stdout/stderr merged into single output.log with 2>&1
 * - Exit code captured via bash trap
 *
 * Uses runtime.tempDir() for output directory, making the code runtime-agnostic.
 *
 * @param runtime Runtime to spawn on
 * @param script Script to execute
 * @param options Spawn options
 */
export async function spawnProcess(
  runtime: Runtime,
  script: string,
  options: SpawnOptions
): Promise<SpawnResult> {
  log.debug(`BackgroundProcessExecutor.spawnProcess: Spawning in ${options.cwd}`);

  // Get temp directory from runtime (absolute path, runtime-agnostic)
  const tempDir = await runtime.tempDir();
  const bgOutputDir = `${tempDir}/${BG_OUTPUT_SUBDIR}`;

  // Use shell-safe quoting for paths (handles spaces, special chars)
  const quotePath = quotePathForShell;

  // Verify working directory exists
  const cwdCheck = await execBuffered(runtime, `cd ${quotePath(options.cwd)}`, {
    cwd: FALLBACK_CWD,
    timeout: 10,
  });
  if (cwdCheck.exitCode !== 0) {
    return { success: false, error: `Working directory does not exist: ${options.cwd}` };
  }

  // Compute output paths (unified output.log instead of separate stdout/stderr)
  const { outputDir, outputPath, exitCodePath } = computeOutputPaths(
    bgOutputDir,
    options.workspaceId,
    options.processId
  );

  // Create output directory and empty file
  try {
    await runtime.ensureDir(outputDir);
    await writeFileString(runtime, outputPath, "");
  } catch (error) {
    return {
      success: false,
      error: `Failed to create output directory: ${errorMsg(error)}`,
    };
  }

  // Build wrapper script (same for all runtimes now that paths are absolute)
  // Note: buildWrapperScript handles quoting internally via shellQuote
  const wrapperScript = buildWrapperScript({
    exitCodePath,
    cwd: options.cwd,
    env: { ...options.env, ...NON_INTERACTIVE_ENV_VARS },
    script,
  });

  const spawnCommand = buildSpawnCommand({
    wrapperScript,
    outputPath,
    quotePath,
  });

  try {
    // No timeout - the spawn command backgrounds the process and returns immediately
    const result = await execBuffered(runtime, spawnCommand, {
      cwd: FALLBACK_CWD,
    });

    if (result.exitCode !== 0) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: spawn command failed: ${result.stderr}`);
      return {
        success: false,
        error: `Failed to spawn background process: ${result.stderr}`,
      };
    }

    const pid = parsePid(result.stdout);
    if (!pid) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: Invalid PID: ${result.stdout}`);
      return {
        success: false,
        error: `Failed to get valid PID from spawn: ${result.stdout}`,
      };
    }

    log.debug(`BackgroundProcessExecutor.spawnProcess: Spawned with PID ${pid}`);
    const handle = new RuntimeBackgroundHandle(runtime, pid, outputDir, quotePath);
    return { success: true, handle, pid, outputDir };
  } catch (error) {
    const errorMessage = errorMsg(error);
    log.debug(`BackgroundProcessExecutor.spawnProcess: Error: ${errorMessage}`);
    return {
      success: false,
      error: `Failed to spawn background process: ${errorMessage}`,
    };
  }
}

/**
 * Unified handle to a background process.
 * Uses runtime.exec for all operations, working identically for local and SSH.
 *
 * Output files (output.log, exit_code) are on the runtime's filesystem.
 * This handle provides lifecycle management via execBuffered commands.
 */
class RuntimeBackgroundHandle implements BackgroundHandle {
  private terminated = false;

  constructor(
    private readonly runtime: Runtime,
    private readonly pid: number,
    public readonly outputDir: string,
    private readonly quotePath: (p: string) => string
  ) {}

  /**
   * Get the exit code from the exit_code file.
   * Returns null if process is still running (file doesn't exist yet).
   */
  async getExitCode(): Promise<number | null> {
    try {
      const exitCodePath = this.quotePath(`${this.outputDir}/${EXIT_CODE_FILENAME}`);
      const result = await execBuffered(
        this.runtime,
        `cat ${exitCodePath} 2>/dev/null || echo ""`,
        { cwd: FALLBACK_CWD, timeout: 10 }
      );
      return parseExitCode(result.stdout);
    } catch (error) {
      log.debug(`RuntimeBackgroundHandle.getExitCode: Error: ${errorMsg(error)}`);
      return null;
    }
  }

  /**
   * Terminate the process group.
   * Sends SIGTERM to process group, waits briefly, then SIGKILL if still running.
   */
  async terminate(): Promise<void> {
    if (this.terminated) return;

    try {
      const exitCodePath = `${this.outputDir}/${EXIT_CODE_FILENAME}`;
      const terminateCmd = buildTerminateCommand(this.pid, exitCodePath, this.quotePath);
      await execBuffered(this.runtime, terminateCmd, {
        cwd: FALLBACK_CWD,
        timeout: 15,
      });
      log.debug(`RuntimeBackgroundHandle: Terminated process group ${this.pid}`);
    } catch (error) {
      // Process may already be dead - that's fine
      log.debug(`RuntimeBackgroundHandle.terminate: Error: ${errorMsg(error)}`);
    }

    this.terminated = true;
  }

  /**
   * Clean up resources.
   * No resources to clean - process runs independently via nohup.
   */
  async dispose(): Promise<void> {
    // No resources to clean up
  }

  /**
   * Write meta.json to the output directory.
   */
  async writeMeta(metaJson: string): Promise<void> {
    try {
      const metaPath = this.quotePath(`${this.outputDir}/meta.json`);
      await execBuffered(this.runtime, `cat > ${metaPath} << 'METAEOF'\n${metaJson}\nMETAEOF`, {
        cwd: FALLBACK_CWD,
        timeout: 10,
      });
    } catch (error) {
      log.debug(`RuntimeBackgroundHandle.writeMeta: Error: ${errorMsg(error)}`);
    }
  }

  async getOutputFileSize(): Promise<number> {
    try {
      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);
      const sizeResult = await execBuffered(
        this.runtime,
        `wc -c < ${filePath} 2>/dev/null || echo 0`,
        { cwd: FALLBACK_CWD, timeout: 10 }
      );

      return parseInt(sizeResult.stdout.trim(), 10) || 0;
    } catch (error) {
      log.debug(`RuntimeBackgroundHandle.getOutputFileSize: Error: ${errorMsg(error)}`);
      return 0;
    }
  }

  /**
   * Read output from output.log at the given byte offset.
   * Uses tail -c to read from offset - works on both Linux and macOS.
   */
  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {
    try {
      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);
      const fileSize = await this.getOutputFileSize();

      if (offset >= fileSize) {
        return { content: "", newOffset: offset };
      }

      // Read from offset to end of file using tail -c (faster than dd bs=1)
      // tail -c +N means "start at byte N" (1-indexed)
      const readResult = await execBuffered(
        this.runtime,
        `tail -c +${offset + 1} ${filePath} 2>/dev/null`,
        { cwd: FALLBACK_CWD, timeout: 30 }
      );

      return {
        content: readResult.stdout,
        newOffset: offset + Buffer.byteLength(readResult.stdout),
      };
    } catch (error) {
      log.debug(`RuntimeBackgroundHandle.readOutput: Error: ${errorMsg(error)}`);
      return { content: "", newOffset: offset };
    }
  }
}

/**
 * Options for migrating a foreground process to background
 */
export interface MigrateOptions {
  /** Working directory (for display in meta.json) */
  cwd: string;
  /** Workspace ID */
  workspaceId: string;
  /** Process ID (e.g., "bash_1") - generated by BackgroundProcessManager */
  processId: string;
  /** Original script being executed */
  script: string;
  /** Output already captured while running in foreground */
  existingOutput: string[];
  /** Human-readable name for the process */
  displayName?: string;
}

/**
 * Result of migrating a foreground process
 */
export type MigrateResult =
  | { success: true; handle: BackgroundHandle; outputDir: string }
  | { success: false; error: string };

/**
 * Migrate a foreground process to background tracking.
 *
 * This is called when user clicks "Background" on a running foreground process.
 * The process continues running, but we:
 * 1. Create output directory and write existing output
 * 2. Continue consuming streams and writing to unified output.log
 * 3. Track exit code when process completes
 * 4. Return a BackgroundHandle for the manager to track
 *
 * Note: Output files are written locally (not via runtime), so this works
 * for SSH runtime where streams are already being piped to the local machine.
 *
 * @param execStream The running process's streams
 * @param options Migration options
 * @param bgOutputDir Base directory for output files
 */
export async function migrateToBackground(
  execStream: ExecStream,
  options: MigrateOptions,
  bgOutputDir: string
): Promise<MigrateResult> {
  // Use shared path computation (path.join for local filesystem)
  const { outputDir, outputPath } = computeOutputPaths(
    bgOutputDir,
    options.workspaceId,
    options.processId
  );

  try {
    // Create output directory
    await fs.mkdir(outputDir, { recursive: true });

    // Write existing output to unified output.log
    await fs.writeFile(outputPath, options.existingOutput.join("\n") + "\n");

    // Create handle that will continue writing to file
    const handle = new MigratedBackgroundHandle(execStream, outputDir, outputPath);

    // Start consuming remaining output in background
    handle.startConsuming();

    return { success: true, handle, outputDir };
  } catch (error) {
    const errorMessage = errorMsg(error);
    log.debug(`migrateToBackground: Error: ${errorMessage}`);
    return { success: false, error: `Failed to migrate process: ${errorMessage}` };
  }
}

/**
 * Handle for a migrated foreground process.
 *
 * Unlike RuntimeBackgroundHandle which uses runtime.exec for file operations,
 * this handle uses local filesystem directly because the streams are already
 * being piped to the local machine (even for SSH runtime).
 *
 * Both stdout and stderr are written to a unified output.log file.
 */
class MigratedBackgroundHandle implements BackgroundHandle {
  private exitCodeValue: number | null = null;
  private consuming = false;
  private outputFd: fs.FileHandle | null = null;

  constructor(
    private readonly execStream: ExecStream,
    public readonly outputDir: string,
    private readonly outputPath: string
  ) {}

  /**
   * Start consuming remaining output from streams and writing to unified file.
   * Called after handle is created to begin background file writing.
   */
  startConsuming(): void {
    if (this.consuming) return;
    this.consuming = true;

    // Open output file once, consume both streams to it
    void this.consumeStreams();

    // Track exit code
    void this.execStream.exitCode.then((code) => {
      this.exitCodeValue = code;
      // Write exit code to file
      void this.writeExitCode(code);
    });
  }

  /**
   * Consume both stdout and stderr streams and append to unified output file.
   */
  private async consumeStreams(): Promise<void> {
    try {
      this.outputFd = await fs.open(this.outputPath, "a");

      // Consume both streams concurrently, both writing to same file
      await Promise.all([
        this.consumeStream(this.execStream.stdout),
        this.consumeStream(this.execStream.stderr),
      ]);
    } catch (error) {
      log.debug(`MigratedBackgroundHandle.consumeStreams: ${errorMsg(error)}`);
    } finally {
      if (this.outputFd) {
        await this.outputFd.close();
        this.outputFd = null;
      }
    }
  }

  /**
   * Consume a stream and append to the shared output file.
   */
  private async consumeStream(stream: ReadableStream<Uint8Array>): Promise<void> {
    try {
      const reader = stream.getReader();

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value && this.outputFd) {
            await this.outputFd.write(value);
          }
        }
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      // Stream may have been cancelled or process killed - that's fine
      log.debug(`MigratedBackgroundHandle.consumeStream: ${errorMsg(error)}`);
    }
  }

  /**
   * Write exit code to file.
   */
  private async writeExitCode(code: number): Promise<void> {
    try {
      const exitCodePath = path.join(this.outputDir, EXIT_CODE_FILENAME);
      await fs.writeFile(exitCodePath, String(code));
    } catch (error) {
      log.debug(`MigratedBackgroundHandle.writeExitCode: ${errorMsg(error)}`);
    }
  }

  getExitCode(): Promise<number | null> {
    return Promise.resolve(this.exitCodeValue);
  }

  async terminate(): Promise<void> {
    // ExecStream doesn't expose a kill method directly
    // Cancel the streams to stop reading (process continues but we stop tracking)
    try {
      await this.execStream.stdout.cancel();
      await this.execStream.stderr.cancel();
    } catch {
      // Streams may already be closed
    }
  }

  async dispose(): Promise<void> {
    // Close any open file handles
    await this.outputFd?.close().catch(() => {
      /* ignore */
    });
  }

  async getOutputFileSize(): Promise<number> {
    try {
      const stat = await fs.stat(this.outputPath);
      return stat.size;
    } catch (error) {
      log.debug(`MigratedBackgroundHandle.getOutputFileSize: ${errorMsg(error)}`);
      return 0;
    }
  }

  async writeMeta(metaJson: string): Promise<void> {
    try {
      const metaPath = path.join(this.outputDir, "meta.json");
      await fs.writeFile(metaPath, metaJson);
    } catch (error) {
      log.debug(`MigratedBackgroundHandle.writeMeta: ${errorMsg(error)}`);
    }
  }

  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {
    try {
      const fileSize = await this.getOutputFileSize();

      if (offset >= fileSize) {
        return { content: "", newOffset: offset };
      }

      // Read from offset to end
      const fd = await fs.open(this.outputPath, "r");
      try {
        const buffer = Buffer.alloc(fileSize - offset);
        const { bytesRead } = await fd.read(buffer, 0, buffer.length, offset);
        return {
          content: buffer.slice(0, bytesRead).toString("utf-8"),
          newOffset: offset + bytesRead,
        };
      } finally {
        await fd.close();
      }
    } catch (error) {
      log.debug(`MigratedBackgroundHandle.readOutput: ${errorMsg(error)}`);
      return { content: "", newOffset: offset };
    }
  }
}
